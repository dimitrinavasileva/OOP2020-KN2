> A __default constructor__ is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter). A type with a public default constructor is DefaultConstructible.

> Syntax
```c++
class_name ( ) ;	(1)	
class_name :: class_name ( ) body	(2)	
class_name() = delete ;	(3)	(since C++11)
class_name() = default ;	(4)	(since C++11)
class_name :: class_name ( ) = default ;	(5)	(since C++11)
```
> Where class_name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.

> Explanation
>   - 1) Declaration of a default constructor inside of class definition.
>   - 2) Definition of the constructor outside of class definition (the class must contain a declaration (1)). See constructors and member initializer lists for details on the constructor body
>   - 3) Deleted default constructor: if it is selected by overload resolution, the program fails to compile.
>   - 4) Defaulted default constructor: the compiler will define the implicit default constructor even if other constructors are present.
>   - 5) Defaulted default constructor outside of class definition (the class must contain a declaration (1)). Such constructor is treated as user-provided (see below and value initialization).

> Default constructors are called during default initializations and value initializations.

> A __copy constructor__ of class T is a non-template constructor whose first parameter is T&‍, const T&‍, volatile T&‍, or const volatile T&‍, and either there are no other parameters, or the rest of the parameters all have default values.
> Syntax
```c++
class_name ( const class_name & )	(1)	
class_name ( const class_name & ) = default;	(2)	
class_name ( const class_name & ) = delete;	(3)	
```
> Where class_name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.

> Explanation
>   - (1) Typical declaration of a copy constructor.
>   - (2) Forcing a copy constructor to be generated by the compiler.
>   - (3) Avoiding implicit generation of the copy constructor.

> A __copy assignment operator__ of class T is a non-template non-static member function with the name operator= that takes exactly one parameter of type T, T&, const T&, volatile T&, or const volatile T&. For a type to be CopyAssignable, it must have a public copy assignment operator.

> Syntax
```c++
class_name & class_name :: operator= ( class_name )	(1)	
class_name & class_name :: operator= ( const class_name & )	(2)	
class_name & class_name :: operator= ( const class_name & ) = default;	(3)	(since C++11)
class_name & class_name :: operator= ( const class_name & ) = delete;	(4)	(since C++11)
```

> Explanation
>   - (1) Typical declaration of a copy assignment operator when copy-and-swap idiom can be used.
>   - (2) Typical declaration of a copy assignment operator when copy-and-swap idiom cannot be used (non-swappable type or degraded performance).
>   - (3) Forcing a copy assignment operator to be generated by the compiler.
>   - (4) Avoiding implicit copy assignment.
> The copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression.

> A __destructor__ is a special member function that is called when the lifetime of an object ends. The purpose of the destructor is to free the resources that the object may have acquired during its lifetime.

> Syntax
```c++
~ class_name ();	(1)	
virtual ~ class_name ();	(2)	
decl-specifier-seq(optional) ~ class_name () = default;	(3)	(since C++11)
decl-specifier-seq(optional) ~ class_name () = delete;	(4)	(since C++11)
```
> Explanation
>   - 1) Typical declaration of a destructor
>   - 2) Virtual destructor is usually required in a base class
>   - 3) Forcing a destructor to be generated by the compiler
>   - 4) Disabling the implicit destructor

> The information is taken from [here](https://en.cppreference.com/w/cpp/language)
